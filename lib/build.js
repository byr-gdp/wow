#!/usr/bin/env node

const path = require('path');
const fs = require('fs');
const readMarkdownDirectory = require('../lib/utils/readMarkdownDirectory');
const createDirIfNeeded = require('../lib/utils/createDirIfNeeded');
const compileTemplate = require('../lib/template/compileTemplate');
const cleanDir = require('../lib/utils/cleanDir');

/**
 * markdown 文件构建生成 html
 * @param {Sring} sourceDir 源文件目录绝对路径
 * @param {String} outputDir 输出目录绝对路径
 */
function build(sourceDir, outputDir) {
  const makrdownDirAbsolutePath = path.resolve(process.cwd(), sourceDir);
  const outputDirAbsolutePath = path.resolve(process.cwd(), outputDir);

  cleanDir(outputDirAbsolutePath);
  createDirIfNeeded(makrdownDirAbsolutePath);
  createDirIfNeeded(outputDirAbsolutePath);

  const fileMap = readMarkdownDirectory(makrdownDirAbsolutePath);
  const articles = Object.keys(fileMap).map(file => file.slice(file.lastIndexOf('/') + 1, -3) + '.html');

  // 将 markdown 转换成 html 并写入文件
  Object.keys(fileMap).forEach((file) => {
    // 假设所有文件以 .md 结尾，且文件命名除后缀外没有 '.'

    // TODO：由于存在多目录的情况，而导出文件是扁平结构，多目录的文件若文件名重复会导致生成 html 相互覆盖，所以文件名应该基于 sourceDir 并且将子目录 '/' 换成 '_' 分隔保证文件名不重复。
    // 根据 file 路径获取文件名
    const filename = file.slice(file.lastIndexOf('/') + 1, -3) + '.html';

    const html = fileMap[file];
    const data = {
      html,
      articles,
    };

    const outputFileAbsolutePath = path.resolve(outputDirAbsolutePath, filename);
    fs.writeFileSync(outputFileAbsolutePath, compileTemplate(data), {
      encoding: 'utf8'
    });
  });

  // 如果没有 index.md 则自动生成兜底页面
  if (!articles.includes('index.html')) {
    const data = {
      html: '<h1>Welcome</h1><p>This is generated by Wow.</p>',
      articles,
    };

    const filename = 'index.html';
    const outputFileAbsolutePath = path.resolve(outputDirAbsolutePath, filename);
    fs.writeFileSync(outputFileAbsolutePath, compileTemplate(data), {
      encoding: 'utf8'
    });
  }
}

module.exports = exports = build;
